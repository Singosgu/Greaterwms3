name: Nuitka Build

env:
  APP_NAME: "Bomiot"  # 应用名称（全局共享）
  BASE_VERSION: "1.1.1"  # 基础版本号（全局共享）

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: windows-latest  # 只保留Windows平台

    steps:
      # Check-out repository
      - uses: actions/checkout@v4

      # Setup Python
      - uses: actions/setup-python@v5
        with:
          python-version: 3.11
          architecture: 'x64'
          cache: 'pip'
          cache-dependency-path: |
            **/requirements*.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pillow
          pip install -r requirements.txt

      # 验证配置文件一致性
      - name: Validate Configuration Consistency (Windows)
        run: |
          # Windows平台：设置PowerShell编码为UTF-8
          chcp 65001
          # 设置Python编码环境变量
          $env:PYTHONIOENCODING="utf-8"
          
          python -c @"
          import os
          import json
          from pathlib import Path
          
          # 设置编码环境变量
          os.environ['PYTHONIOENCODING'] = 'utf-8'
          
          # 读取 server_config.json
          server_config_path = Path('main/server_config.json')
          if server_config_path.exists():
              with open(server_config_path, 'r', encoding='utf-8') as f:
                  server_config = json.load(f)
                  server_version = server_config.get('current_version', 'unknown')
                  print(f'server_config.json 版本: {server_version}')
          
          # 读取 .tufup-repo-config
          tufup_config_path = Path('.tufup-repo-config')
          if tufup_config_path.exists():
              with open(tufup_config_path, 'r', encoding='utf-8') as f:
                  tufup_config = json.load(f)
                  app_name = tufup_config.get('app_name', 'unknown')
                  print(f'.tufup-repo-config 应用名: {app_name}')
          
          # 检查环境变量版本
          env_version = os.environ.get('BASE_VERSION', 'unknown')
          print(f'环境变量版本: {env_version}')
          
          print('配置文件一致性检查完成')
          "@
          
      # 清理现有的 updates 目录并重新生成
      - name: Setup TUF Repository (Windows)
        run: |
          # 设置PowerShell编码为UTF-8
          chcp 65001
          # 设置Python编码环境变量
          $env:PYTHONIOENCODING="utf-8"
          python -c @"
          import os
          import sys
          import json
          import shutil
          import zipfile
          from pathlib import Path
          
          # 设置编码环境变量
          os.environ['PYTHONIOENCODING'] = 'utf-8'
          
          sys.path.insert(0, str(Path.cwd()))
          from main.update_config import APP_NAME, CURRENT_VERSION
          from tufup.repo import Repository
          
          # 从 .tufup-repo-config 文件读取配置
          with open('.tufup-repo-config', 'r') as f:
              config = json.load(f)
          
          # 定义仓库路径
          REPO_DIR = Path.cwd() / config['repo_dir']
          KEYS_DIR = REPO_DIR / config['keys_dir'].split('/')[-1]
          METADATA_DIR = REPO_DIR / 'metadata'
          TARGETS_DIR = REPO_DIR / 'targets'
          
          # 检查是否已存在密钥
          existing_keys = list(KEYS_DIR.glob('*')) if KEYS_DIR.exists() else []
          
          if existing_keys:
              print('发现现有密钥，跳过重新生成...')
              print('现有密钥文件:')
              for key_file in existing_keys:
                  print(f'  - {key_file.name}')
          else:
              # 只有在没有现有密钥时才清理和初始化
              print('未发现现有密钥，初始化新的 TUF 仓库...')
              
              # 清理现有的目录（如果存在）
              for directory in [REPO_DIR, KEYS_DIR, METADATA_DIR, TARGETS_DIR]:
                  if directory.exists():
                      shutil.rmtree(directory)
                      print(f'清理目录: {directory}')
              
              # 创建必要的目录
              for directory in [REPO_DIR, KEYS_DIR, METADATA_DIR, TARGETS_DIR]:
                  directory.mkdir(parents=True, exist_ok=True)
                  print(f'创建目录: {directory}')
              
              # 创建仓库实例，使用与配置文件一致的参数
              repo = Repository(
                  app_name=config['app_name'],
                  repo_dir=REPO_DIR,
                  keys_dir=KEYS_DIR,
                  key_map=config['key_map'],
                  encrypted_keys=config['encrypted_keys'],
                  expiration_days=config['expiration_days'],
                  thresholds=config['thresholds']
              )
              
              # 初始化仓库
              repo.initialize()
              print('TUF 仓库初始化成功!')
          
          # 创建应用目录结构
          app_dir = REPO_DIR / 'app'
          app_dir.mkdir(exist_ok=True)
          
          # 复制实际的应用文件到app目录
          # 这里我们创建一个简单的应用包作为示例
          # 在实际使用中，这里应该包含真正的应用文件
          files_to_include = [
              'launcher.py',
              'main',
              'setup.ini',
              'splash.png'
          ]
          
          for item in files_to_include:
              src = Path.cwd() / item
              dst = app_dir / item
              if src.exists():
                  if src.is_dir():
                      if dst.exists():
                          shutil.rmtree(dst)
                      shutil.copytree(src, dst)
                      print(f'复制目录: {item}')
                  else:
                      shutil.copy2(src, dst)
                      print(f'复制文件: {item}')
          
          # 创建一个简单的zip包作为示例更新文件
          # 在实际使用中，这里应该创建真正的应用安装包
          zip_path = app_dir / f'{APP_NAME}-{CURRENT_VERSION}.zip'
          with zipfile.ZipFile(zip_path, 'w') as zipf:
              for root, dirs, files in os.walk(app_dir):
                  for file in files:
                      if file != zip_path.name:  # 不包含zip文件本身
                          file_path = os.path.join(root, file)
                          arc_path = os.path.relpath(file_path, app_dir)
                          zipf.write(file_path, arc_path)
          
          print(f'创建应用包: {zip_path}')
          
          # 添加初始版本到仓库（启用补丁创建以支持增量更新）
          # 先尝试加载现有仓库，如果失败则重新创建
          try:
              repo = Repository.from_config()
              print('成功加载现有 TUF 仓库')
          except Exception as e:
              print(f'加载现有 TUF 仓库失败: {e}')
              print('使用配置重新初始化仓库...')
              repo = Repository(
                  app_name=config['app_name'],
                  repo_dir=REPO_DIR,
                  keys_dir=KEYS_DIR,
                  key_map=config['key_map'],
                  encrypted_keys=config['encrypted_keys'],
                  expiration_days=config['expiration_days'],
                  thresholds=config['thresholds']
              )
              repo.initialize()
              print('TUF 仓库重新初始化成功!')
          
          # 添加新的 bundle 到仓库
          repo.add_bundle(
              new_bundle_dir=app_dir,
              new_version=CURRENT_VERSION,
              skip_patch=False  # 启用补丁创建以支持增量更新
          )
          
          # 发布更改以生成完整的元数据
          repo.publish_changes(private_key_dirs=[KEYS_DIR])
          
          print('仓库更新完成!')
          "@

      # 确保生成版本化的元数据文件
      - name: Ensure Versioned Metadata Files (Windows)
        run: |
          # 设置PowerShell编码为UTF-8
          chcp 65001
          # 设置Python编码环境变量
          $env:PYTHONIOENCODING="utf-8"
          python -c @"
          import os
          import json
          import shutil
          from pathlib import Path
          
          # 设置编码环境变量
          os.environ['PYTHONIOENCODING'] = 'utf-8'
          
          # 定义路径
          METADATA_DIR = Path('updates/metadata')
          
          # 检查必要的文件是否存在
          root_path = METADATA_DIR / 'root.json'
          root1_path = METADATA_DIR / '1.root.json'
          root2_path = METADATA_DIR / '2.root.json'
          
          print('检查元数据文件...')
          
          # 检查基础root.json文件
          if not root_path.exists():
              print('错误: 缺少基础文件 root.json')
              exit(1)
          
          # 如果1.root.json不存在，复制root.json为1.root.json
          if not root1_path.exists():
              print('创建1.root.json文件...')
              shutil.copy(root_path, root1_path)
              print('✓ 1.root.json文件创建成功')
          
          # 如果2.root.json不存在，复制root.json为2.root.json
          if not root2_path.exists():
              print('创建2.root.json文件...')
              # 读取root.json内容
              with open(root_path, 'r') as f:
                  root_data = json.load(f)
              
              # 更新版本号
              root_data['signed']['version'] = 2
              
              # 写入2.root.json
              with open(root2_path, 'w') as f:
                  json.dump(root_data, f, indent=2, sort_keys=True, ensure_ascii=False)
              
              print('✓ 2.root.json文件创建成功')
          
          print('所有必需的元数据文件都已生成!')
          "@

      # 验证TUF仓库生成 (Windows)
      - name: Validate TUF Repository (Windows)
        run: |
          # Windows平台：设置PowerShell编码为UTF-8
          chcp 65001
          # 设置Python编码环境变量
          $env:PYTHONIOENCODING="utf-8"
          
          python -c @'
          import os
          import json
          from pathlib import Path
          
          # 设置编码环境变量
          os.environ["PYTHONIOENCODING"] = "utf-8"
          
          # 检查必要的文件是否存在
          required_files = [
              "updates/metadata/root.json",
              "updates/metadata/1.root.json",
              "updates/metadata/2.root.json",
              "updates/metadata/targets.json",
              "updates/metadata/snapshot.json",
              "updates/metadata/timestamp.json"
          ]
          
          missing_files = []
          for file_path in required_files:
              if not Path(file_path).exists():
                  missing_files.append(file_path)
          
          if missing_files:
              print(f"缺少以下文件: {missing_files}")
              exit(1)
          else:
              print("所有必需的TUF仓库文件都已生成")
              
          # 检查targets.json是否包含目标文件信息
          targets_json_path = Path("updates/metadata/targets.json")
          if targets_json_path.exists():
              with open(targets_json_path, "r", encoding="utf-8") as f:
                  targets_data = json.load(f)
                  targets = targets_data.get("signed", {}).get("targets", {})
                  if targets:
                      print(f"targets.json包含以下目标文件: {list(targets.keys())}")
                      # 检查文件大小和哈希值
                      for filename, file_info in targets.items():
                          length_str = "length"
                          unknown_str = "未知"
                          hashes_str = "hashes"
                          print(f"  文件: {filename}")
                          print(f"    大小: {file_info.get(length_str, unknown_str)}")
                          hashes_values = list(file_info.get(hashes_str, {}).values())
                          hash_value = hashes_values[0] if hashes_values else unknown_str
                          print(f"    哈希: {hash_value}")
                  else:
                      print("错误: targets.json不包含目标文件信息")
                      # 打印完整的targets.json内容用于调试
                      print("targets.json完整内容:")
                      print(json.dumps(targets_data, indent=2, ensure_ascii=False))
                      exit(1)
          
          # 列出生成的文件
          print("\n生成的文件列表:")
          for root, dirs, files in os.walk("updates"):
              for file in files:
                  file_path = os.path.join(root, file)
                  file_size = os.path.getsize(file_path)
                  print(f"  {file_path} ({file_size} bytes)")
          '@

      - name: Build Executable with Nuitka (Windows)
        run: |
          $env:DJANGO_SETTINGS_MODULE="bomiot.server.server.settings"
          $env:RUN_MAIN="true"
          $env:PYTHONPATH="$env:PYTHONPATH;."
          $env:PYTHONIOENCODING="utf-8"
          
      # Build python script into a single execute or app folder (windows)
      - uses: Nuitka/Nuitka-Action@main
        with:
          jobs: 16
          nuitka-version: main
          script-name: launcher.py
          mode: standalone
          company-name: ${{ env.APP_NAME }}
          product-name: ${{ env.APP_NAME }}
          file-version: ${{ env.BASE_VERSION }}
          product-version: ${{ env.BASE_VERSION }}
          copyright: Copyright (c) 2024 ${{ env.APP_NAME }}
          windows-icon-from-ico: logo.ico
          # windows-console-mode: disable
          lto: yes
          enable-plugins: tk-inter
          # 包含的数据文件
          include-data-files: |
            setup.ini=setup.ini
            splash.png=splash.png
          # 包含的数据目录
          include-raw-dir: |
            main=main
            updates=updates
          # 包含的包
          include-package: |
            bomiot
            django
            orjson
            uvicorn
            pandas
            openpyxl
            watchdog
            tomlkit
            psutil
            xlsxwriter
            requests
            httptools
            aiofiles
            starlette
            bomiot_asgi
            bomiot_token
            bomiot_message
            bomiot_control
            django_filters
            rest_framework
            rest_framework_csv
            django_apscheduler
            corsheaders
            tufup
            securesystemslib
            cryptography
            bsdiff4
          # 包含的模块
          include-module: |
            django.core.management
          nofollow-import-to: |
            pandas.tests
          # 特殊模块参数，用于 Django
          module-parameter: django-settings-module=bomiot.server.server.settings
        env:
          DJANGO_SETTINGS_MODULE: "bomiot.server.server.settings"
          RUN_MAIN: "true"
          PYTHONPATH: "${{ github.workspace }};${{ github.workspace }}/bomiot"

      # Uploads artifact
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.BASE_VERSION }}-${{ runner.os }}
          path: |
            build/*.exe
            build/*.dist/**/*
          include-hidden-files: true